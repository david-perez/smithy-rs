use axum::{handler::get, Router};
use derive_builder::Builder;
use model::*;
use runtime::AwsRestJson1;
use simple::output;
use std::future::Future;
use std::marker::PhantomData;

pub mod extractors;
pub mod model;
pub mod responders;
pub mod runtime;

fn fun<F, Fut, B, Res, T1>(_: F)
where
    F: FnOnce(T1) -> Fut + Clone + Send + Sync + 'static,
    Fut: Future<Output = Res> + Send,
    B: Send + 'static,
    Res: axum::response::IntoResponse,
    T1: axum::extract::FromRequest<B> + Send,
{
}

// ============================================================
// Code-generated by `smithy-rs` in `operation_registry` module
// ============================================================

#[derive(Builder, Debug)]
#[builder(pattern = "owned")]
struct SimpleServiceOperationRegistry<C1, Fut1, C2, Fut2> {
    pub health_check: C1,
    pub register_service: C2,

    _phantom_fut1: PhantomData<Fut1>,
    _phantom_fut2: PhantomData<Fut2>,
}

// Auto-generated depending on Smithy protocol.
// TODO What happens if a Smithy service definition supports more than one protocol?
// This doesn't violate coherence because we control the Cx, Futx type parameters.
impl<C1, Fut1, C2, Fut2> From<SimpleServiceOperationRegistry<C1, Fut1, C2, Fut2>> for Router<axum::routing::BoxRoute>
where
    C1: FnOnce(HealthcheckInput) -> Fut1 + Clone + Send + Sync + 'static,
    Fut1: Future<Output = HealthcheckOutput> + Send,
    C2: FnOnce(AwsRestJson1<RegisterServiceInput>) -> Fut2 + Clone + Send + Sync + 'static,
    Fut2: Future<Output = Result<RegisterServiceOutput, RegisterServiceError>> + Send,
{
    fn from(registry: SimpleServiceOperationRegistry<C1, Fut1, C2, Fut2>) -> Self {
        // fun(registry.register_service);

        Router::new()
            .route("/healthcheck", get(registry.health_check))
            .route("/register_service", get(registry.register_service))
            .boxed()
    }
}

// ====================
// What the user writes
// ====================

// Notice how this operation implementation does not return `Result<T, E>`, because the Smithy
// model declares this operation as being infallible (no `errors` property:
// https://awslabs.github.io/smithy/1.0/spec/core/model.html#operation).
async fn healthcheck_operation(_input: HealthcheckInput) -> HealthcheckOutput {
    HealthcheckOutput(output::HealthcheckOutput::builder().build())
}

async fn register_service_operation(
    _input: AwsRestJson1<RegisterServiceInput>,
) -> Result<RegisterServiceOutput, RegisterServiceError> {
    Ok(RegisterServiceOutput(output::RegisterServiceOutput::builder().id(String::from("id")).build()))
}

#[tokio::main]
async fn main() {
    let app: Router<axum::routing::BoxRoute> = SimpleServiceOperationRegistryBuilder::default()
        // User builds a registry containing implementations to all the operations in the service.
        // These are async functions or async closures that take as input the operation's
        // input and return the operation's output.
        .health_check(healthcheck_operation)
        .register_service(register_service_operation)
        .build()
        .unwrap()
        // Convert it into an axum router that will route requests to the matching operation
        // implementation.
        .into();

    // User has the ability to modify app if they desire.
    // They can add layers to **all** routes.
    // TODO How can they add layers per route? They can't modify the routes in the router to wrap
    // them in https://docs.rs/axum/0.2.8/axum/handler/trait.Handler.html#method.layer

    let server = axum::Server::bind(&"0.0.0.0:8080".parse().unwrap()).serve(app.into_make_service());

    // Run forever-ish...
    if let Err(err) = server.await {
        eprintln!("server error: {}", err);
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let val = 4;
        assert_eq!(val, 4);
    }
}
