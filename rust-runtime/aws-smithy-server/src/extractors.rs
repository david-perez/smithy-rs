// =============================
// Code-generated by `smithy-rs`
// =============================

use crate::{
    model::*,
    runtime::{json_content_type, AwsRestJson1},
};
use axum::{
    async_trait,
    extract::{FromRequest, RequestParts},
    BoxError,
};
// The `json_deser` module is private so this only compiles if you go into the generated `lib.rs`
// and make it public. We won't need to make it public though, because the generated `extractors`
// module will have access to it.
use simple::{error, input, json_deser, operation_deser};

#[async_trait]
impl<B> FromRequest<B> for AwsRestJson1<RegisterServiceInput>
where
    B: http_body::Body + Send,
    B::Data: Send,
    B::Error: Into<BoxError>,
{
    // I'm using a simple status code as the rejection type because the useful rejection types in
    // `axum` are not instantiable: https://docs.rs/axum/0.2.8/axum/extract/rejection/index.html
    // This is because all the enum variants take in unit structs that are marked
    // `[#non_exhaustive]`, and are therefore private: see "Non-exhaustive types cannot be
    // constructed outside of the defining crate" in
    // https://doc.rust-lang.org/reference/attributes/type_system.html
    // This means that we'd have to create our own rejection types, which amounts to largely
    // copying from here:
    //     * https://github.com/tokio-rs/axum/blob/main/src/extract/rejection.rs
    //     * https://github.com/tokio-rs/axum/blob/main/src/macros.rs
    type Rejection = http::StatusCode;

    async fn from_request(req: &mut RequestParts<B>) -> Result<Self, Self::Rejection> {
        // TODO Replace this with a meaningful error.
        let rejection = http::StatusCode::from_u16(400).unwrap();

        if !json_content_type(req)? {
            return Err(rejection);
        }

        let mut input = input::register_service_input::Builder::default();

        // Extract things from the request that are not the body. For example, like here, from
        // the URI.
        lazy_static::lazy_static! {
            static ref RE: regex::Regex = regex::Regex::new("/service/(?P<id>[^/]+)").unwrap();
        }
        if let Some(captures) = RE.captures(req.uri().path()) {
            if let Some(m) = captures.name("id") {
                input = input
                    .set_id(operation_deser::deser_label_register_service_input_id(m.as_str()).map_err(|_| rejection)?);
            }
        }

        // Extract things from the body.
        let body = req.take_body().ok_or(rejection)?;

        // Convert the body to bytes. Ideally we'd use
        // [`hyper::body::aggregate`](https://docs.rs/hyper/0.14.13/hyper/body/fn.aggregate.html)
        // instead, provided we can write our deserializers so that they don't require a
        // contiguous buffer, like the Serde ones. But I think that's not easy.
        let bytes = hyper::body::to_bytes(body).await.map_err(|_| rejection)?;

        input = json_deser::deser_structure_crate_input_register_service_input(&bytes, input).map_err(|_| rejection)?;

        let value = input
            .build()
            .map(|inner| RegisterServiceInput(inner))
            .map_err(error::Error::from)
            .map_err(|_| rejection)?;

        Ok(AwsRestJson1(value))
    }
}

// Same thing for the other operation.

#[async_trait]
impl<B> FromRequest<B> for HealthcheckInput
where
    B: Send, // required by `async_trait`
{
    // Or anything that implements `IntoResponse`.
    // TODO Should this be the SmithyError? Not really; rather, a deserialization-specific error
    // provided by the framework.
    type Rejection = http::StatusCode;

    async fn from_request(_req: &mut RequestParts<B>) -> Result<Self, Self::Rejection> {
        // TODO Why do builders for input structs return `Result<T, E>` but those for output
        // structs return `Result<T>`?
        Ok(HealthcheckInput(input::HealthcheckInput::builder().build().unwrap()))
    }
}
