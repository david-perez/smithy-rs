// =============================
// Code-generated by `smithy-rs`
// =============================

use crate::model::*;
use crate::routing::{operation_handler::operation, request_spec::RequestSpec, Router};
use crate::runtime::AwsRestJson1;
use derive_builder::Builder;
use std::future::Future;
// use std::marker::PhantomData;

fn _fun<F, Fut, B, Res, T1>(_: F)
where
    F: FnOnce(T1) -> Fut + Clone + Send + Sync + 'static,
    Fut: Future<Output = Res> + Send,
    B: Send + 'static,
    Res: axum::response::IntoResponse,
    T1: axum::extract::FromRequest<B> + Send,
{
}

#[derive(Builder, Debug)]
#[builder(pattern = "owned")]
pub struct SimpleServiceOperationRegistry<C1, Fut1, C2, Fut2>
where
    C1: FnOnce(HealthcheckInput) -> Fut1 + Clone + Send + Sync + 'static,
    Fut1: Future<Output = HealthcheckOutput> + Send,
    C2: FnOnce(AwsRestJson1<RegisterServiceInput>) -> Fut2 + Clone + Send + Sync + 'static,
    Fut2: Future<Output = Result<RegisterServiceOutput, RegisterServiceError>> + Send,
{
    pub health_check: C1,
    pub register_service: C2,
    // We use `PhantomData` here just to not have to specify the trait bounds twice (once in the
    // struct declaration, another in the `impl` block below).
    // However, the `derive_builder` crate does not work with `PhantomData` fields, so `.build().unwrap()`
    // will fail when running the binary. This is therefore commented out. I think this sould be an
    // issue in the `derive_builder` crate.
    // _phantom_fut1: PhantomData<Fut1>,
    // _phantom_fut2: PhantomData<Fut2>,
}

// Auto-generated depending on Smithy protocol.
// TODO What happens if a Smithy service definition supports more than one protocol?
// This doesn't violate coherence because we control the Cx, Futx type parameters.
impl<C1, Fut1, C2, Fut2> From<SimpleServiceOperationRegistry<C1, Fut1, C2, Fut2>> for Router
where
    C1: FnOnce(HealthcheckInput) -> Fut1 + Clone + Send + Sync + 'static,
    Fut1: Future<Output = HealthcheckOutput> + Send,
    C2: FnOnce(AwsRestJson1<RegisterServiceInput>) -> Fut2 + Clone + Send + Sync + 'static,
    Fut2: Future<Output = Result<RegisterServiceOutput, RegisterServiceError>> + Send,
{
    fn from(registry: SimpleServiceOperationRegistry<C1, Fut1, C2, Fut2>) -> Self {
        // fun(registry.register_service);

        let request_spec = RequestSpec::always_get();
        let request_spec2 = RequestSpec::always_get();

        let router = Router::new()
            .route(request_spec, operation(registry.health_check))
            .route(request_spec2, operation(registry.register_service));

        router
    }
}
